; 121 - 数据变成字符串显示【设计一 完整版】
; =================================================================

; 将data段中的数据以十进制的形式显示出来

; =================================================================
assume cs:code, ds:data, ss:stack
; =================================================================
data segment
		dw	1234, 0
data ends
; =================================================================
string segment
		   ;0123456789   A	栈的思想
		db '0000000000', 0
		;	  1234
string ends
; =================================================================
stack segment stack
		db	128 dup (0)
stack ends
; =================================================================
code segment
start:		mov ax ,stack
		mov ss, ax
		mov sp, 128

		mov ax, data
		mov ds, ax
		mov si, 0

		mov ax, string
		mov es, ax
		mov di, 10	; 入栈需要修改栈顶标记

		mov ax, ds:[si]
		mov dx, 0

		call short_div

		mov ax, string 
		mov ds, ax
		mov si, di


	;	call dtoc

		mov ax, 0B800H
		mov es, ax
		;mov di, 160 * 3




		mov dl, 15
		mov dh, 9
		mov cl, 11000010B
		call show_str

		mov ax, 4c00h
		int 21h
		

	; ------------------------------------
	short_div:	mov cx, 10
			div cx
			add dl, 30H
			sub di, 1
			mov es:[di], dl
			;mov byte ptr es:[di + 1], 00000010B
		
			mov cx, ax
			jcxz _retShortDiv
			mov dx, 0
			jmp short_div
	
		_retShortDiv:	ret
			


	; ------------------------------------
	; 名称：dtoc
	; 功能：将word型数据转变为表示十进制的字符串，字符串以0结尾
	; 参数：(ax)=word型数据
	;	ds:si 指向字符串首地址
	; 返回值：无
	dtoc:		


			ret

	
	; -------------------------------------
	; 1. 显示字符串
	; 名称：show_str
	; 功能：在指定位置，用指定颜色，显示一个用0结束的字符串
	; 参数：(dh)=行号（取值范围0~24）,（dl）=列号（取值范围0~79）
	; 	(cl)=颜色，ds:si指向字符串首地址
	; 
	; 返回：无
	;
	; 应用举例：在屏幕的8行3列，用绿色显示data段中的字符串
	;
	show_str: 	push ax
			push bx
			push ds
			push es
			push di
			push si
			push cx
			push dx
			
			mov ah, 0 
			mov al, 160
			mov dh, 0
			mov bx, dx
			mov dx, 0
			mul bx
			pop dx
			mov dh, 0
			add ax, dx	; 注意这里加两遍，不能简单地将列号相加，因为显示一个字符用了两个字节
			add ax, dx
			mov bx, ax

			; 确定输出的位置

		_showStr:	mov cx, 0
				mov cl, ds:[si + 0]
				jcxz _retShowStr
				mov es:[bx + 0], cl
				pop cx
				push cx
				mov byte ptr es:[bx + 1], cl
				inc si
				add bx, 2
				jmp _showStr

		_retShowStr:	pop cx
				pop si
				pop di
				pop es
				pop ds
				pop bx
				pop ax
				ret


	
code ends

end start

