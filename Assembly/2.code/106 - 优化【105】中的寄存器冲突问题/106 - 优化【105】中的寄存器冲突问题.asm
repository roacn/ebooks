; 106 - 优化【105】中的寄存器冲突问题
; =================================================================
; 
; =================================================================
; 编程：将data段中的字符串转换为大写
; =================================================================






; 为防止寄存器冲突，子程序标准框架如下


;	子程序开始：	!!!!!!! 子程序使用的寄存器入栈 !!!!!!!


;			子程序内容


;			!!!!!!! 子程序使用的寄存区出栈 !!!!!!!


;			程序返回（ret、retf）


; 注意在子程序中push和pop！！！！！
; 这么做的优点是：编写子程序时不必关心调用者使用了哪些寄存器，避免了寄存器冲突！！！
; 但是要注意出栈和入栈的顺序





; =================================================================

assume cs:codesg, ds:datasg

; =================================================================

datasg segment
		db 'word', 0
		db 'unix', 0
		db 'wind', 0
		db 'good', 0
datasg ends

; =================================================================


codesg segment
start:			mov ax, datasg
			mov ds, ax
			
			mov cx, 4
			mov di, 0

	loop_row:				;push cx		; 因为call中用到了cx，会造成寄存器冲突，所以在下一语句前先push，用到的时候再pop 取出来

			call capital						; 不要在这里写，在子程序中写
			inc di
						;pop cx		; pop 取出来

			loop loop_row
			
			mov ax, 4c00h
			int 21h


	; --------------------------- 子程序 ---------------------------
	; 说明：将字符串转换为大写，该字符串以零结尾
	; 参数：字符串首地址：ds:[di], (di) = 0
	; 结果：直接更改对应内存单元内容
	capital:	push cx

	jmp_capital:	mov ch, 0
			mov cl, ds:[di]
			jcxz return
			and byte ptr ds:[di], 11011111B
			inc di
			jmp jmp_capital
		
	return:		pop cx ; 注意：return要标在这里了，因为返回前要先pop出来

			ret

codesg ends
end start

; =================================================================;



